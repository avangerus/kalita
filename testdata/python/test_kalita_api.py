#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Kalita API smoke-test script
- Lists meta (modules/entities)
- Optionally tests CRUD on a chosen entity
- Tries to fetch enum catalogs if exposed
Run:
  python test_kalita_api.py --base http://localhost:8080 --module core --entity User
"""
import argparse
import json
import sys
import time
from datetime import datetime, timezone
from typing import Any, Dict, Optional, Tuple

try:
    import requests
except ImportError:
    print("This script needs the 'requests' package. Install it with: pip install requests", file=sys.stderr)
    sys.exit(1)

def pretty(obj: Any) -> str:
    try:
        return json.dumps(obj, ensure_ascii=False, indent=2, sort_keys=True)
    except Exception:
        return str(obj)

def get_json(url: str) -> Tuple[int, Optional[Dict[str, Any]]]:
    try:
        r = requests.get(url, timeout=10)
        ct = r.headers.get("Content-Type", "")
        if "application/json" in ct:
            return r.status_code, r.json()
        else:
            return r.status_code, None
    except Exception as e:
        print(f"GET {url} failed: {e}", file=sys.stderr)
        return 0, None

def post_json(url: str, payload: Dict[str, Any]) -> Tuple[int, Optional[Dict[str, Any]]]:
    try:
        r = requests.post(url, json=payload, timeout=10)
        if r.headers.get("Content-Type", "").startswith("application/json"):
            return r.status_code, r.json()
        try:
            return r.status_code, r.json()
        except Exception:
            return r.status_code, None
    except Exception as e:
        print(f"POST {url} failed: {e}", file=sys.stderr)
        return 0, None

def put_json(url: str, payload: Dict[str, Any]) -> Tuple[int, Optional[Dict[str, Any]]]:
    try:
        r = requests.put(url, json=payload, timeout=10)
        try:
            return r.status_code, r.json()
        except Exception:
            return r.status_code, None
    except Exception as e:
        print(f"PUT {url} failed: {e}", file=sys.stderr)
        return 0, None

def patch_json(url: str, payload: Dict[str, Any]) -> Tuple[int, Optional[Dict[str, Any]]]:
    try:
        r = requests.patch(url, json=payload, timeout=10)
        try:
            return r.status_code, r.json()
        except Exception:
            return r.status_code, None
    except Exception as e:
        print(f"PATCH {url} failed: {e}", file=sys.stderr)
        return 0, None

def delete(url: str) -> int:
    try:
        r = requests.delete(url, timeout=10)
        return r.status_code
    except Exception as e:
        print(f"DELETE {url} failed: {e}", file=sys.stderr)
        return 0

def now_iso() -> str:
    return datetime.now(timezone.utc).replace(microsecond=0).isoformat()

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--base", default="http://localhost:8080", help="Base URL (default: %(default)s)")
    ap.add_argument("--module", help="Module name (e.g., core)")
    ap.add_argument("--entity", help="Entity name (e.g., User)")
    ap.add_argument("--id", help="Record id to use (default: autogenerated)")
    ap.add_argument("--skip-crud", action="store_true", help="Only list meta; skip CRUD test")
    args = ap.parse_args()

    base = args.base.rstrip("/")
    print(f"[i] Base URL: {base}")

    # 1) META LIST
    status, meta = get_json(f"{base}/api/meta")
    print(f"[GET /api/meta] status={status}")
    if meta is not None:
        print(pretty(meta))
    else:
        print("(no JSON body)")

    # 2) Choose entity
    mod = args.module
    ent = args.entity
    if not mod or not ent:
        # try to guess from meta format (expecting something like dict with modules/entities)
        # Fallback to 'core/User'
        mod = mod or "core"
        ent = ent or "User"
        print(f"[i] Using default entity: {mod}/{ent}")

    if args.skip_crud:
        return

    # 3) CRUD smoke test
    rid = args.id or f"pytest-{int(time.time())}"
    created_at = now_iso()
    updated_at = created_at
    base_entity_url = f"{base}/api/{mod}/{ent}"

    print("\n[CREATE]")
    payload = {
        "id": rid,
        "version": 1,
        "created_at": created_at,
        "updated_at": updated_at
    }
    sc, body = post_json(base_entity_url, payload)
    print(f"POST {base_entity_url} -> {sc}")
    if body is not None:
        print(pretty(body))

    print("\n[GET ONE]")
    sc, body = get_json(f"{base_entity_url}/{rid}")
    print(f"GET {base_entity_url}/{rid} -> {sc}")
    if body is not None:
        print(pretty(body))

    print("\n[LIST]")
    sc, body = get_json(base_entity_url)
    print(f"GET {base_entity_url} -> {sc}")
    if body is not None:
        print(pretty(body)[:2000])  # avoid flooding

    print("\n[COUNT]")
    sc, body = get_json(f"{base}/api/{mod}/{ent}/count")
    print(f"GET /api/{mod}/{ent}/count -> {sc}")
    if body is not None:
        print(pretty(body))

    print("\n[PATCH]")
    sc, body = patch_json(f"{base_entity_url}/{rid}", {"version": 2, "updated_at": now_iso()})
    print(f"PATCH {base_entity_url}/{rid} -> {sc}")
    if body is not None:
        print(pretty(body))

    print("\n[DELETE]")
    sc = delete(f"{base_entity_url}/{rid}")
    print(f"DELETE {base_entity_url}/{rid} -> {sc}")

    print("\n[CATALOGS] (best-effort)")
    # If server exposes catalogs under /api/meta/catalog/:name, we can't know names a priori.
    # We'll try to read meta again and look for a 'catalogs' section if present.
    status, meta2 = get_json(f"{base}/api/meta")
    catalogs = None
    if isinstance(meta2, dict):
        for k in ("catalogs", "enums", "dictionaries"):
            if k in meta2 and isinstance(meta2[k], (list, dict)):
                catalogs = meta2[k]
                break
    if catalogs is None:
        print("No catalog names discovered in /api/meta; if you know a name, try: /api/meta/catalog/<name>")
    else:
        print("[i] Discovered catalogs:", pretty(catalogs))
        if isinstance(catalogs, list):
            names = catalogs
        elif isinstance(catalogs, dict):
            names = list(catalogs.keys())
        else:
            names = []
        for name in names[:5]:  # limit
            sc, body = get_json(f"{base}/api/meta/catalog/{name}")
            print(f"GET /api/meta/catalog/{name} -> {sc}")
            if body is not None:
                print(pretty(body))

if __name__ == "__main__":
    main()
